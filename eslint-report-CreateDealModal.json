[{"filePath":"/Users/tomaskovarik/059_PIPECD/PIPECD/frontend/src/components/CreateDealModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1860,1863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1860,1863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4043,4046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4043,4046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":169,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":169,"endColumn":69},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5810,5813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5810,5813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":332,"column":34,"nodeType":"LogicalExpression","messageId":"anyAssignment","endLine":332,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":340,"column":34,"nodeType":"LogicalExpression","messageId":"anyAssignment","endLine":340,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":352,"column":34,"nodeType":"LogicalExpression","messageId":"anyAssignment","endLine":352,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":360,"column":38,"nodeType":"LogicalExpression","messageId":"anyAssignment","endLine":360,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":369,"column":34,"nodeType":"LogicalExpression","messageId":"anyAssignment","endLine":369,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":380,"column":34,"nodeType":"LogicalExpression","messageId":"anyAssignment","endLine":380,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":395,"column":25,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":395,"endColumn":74}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport {\n  Modal,\n  ModalOverlay,\n  ModalContent,\n  ModalHeader,\n  ModalFooter,\n  ModalBody,\n  ModalCloseButton,\n  Button,\n  FormControl,\n  FormLabel,\n  Input,\n  NumberInput,\n  NumberInputField,\n  Select,\n  VStack,\n  FormErrorMessage,\n  Alert, \n  AlertIcon,\n  Spinner,\n  useToast,\n  Switch,\n  CheckboxGroup,\n  Checkbox,\n  Stack,\n  Text,\n} from '@chakra-ui/react';\nimport { usePeopleStore, Person } from '../stores/usePeopleStore';\nimport { useDealsStore } from '../stores/useDealsStore';\nimport { usePipelinesStore, Pipeline } from '../stores/usePipelinesStore';\nimport { useStagesStore, Stage } from '../stores/useStagesStore';\nimport { DealInput, CustomFieldType } from '../generated/graphql/graphql';\nimport { useCustomFieldDefinitionStore } from '../stores/useCustomFieldDefinitionStore';\nimport { CustomFieldEntityType, CustomFieldDefinition as GraphQLCustomFieldDefinition, CustomFieldValueInput } from '../generated/graphql/graphql';\n\n// Reverted: type CustomFormValue = string | number | boolean | string[] | null | undefined;\n\ninterface CreateDealModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onDealCreated: () => void;\n}\n\nfunction CreateDealModal({ isOpen, onClose, onDealCreated }: CreateDealModalProps) {\n  const [name, setName] = useState('');\n  const [localSelectedPipelineId, setLocalSelectedPipelineId] = useState<string>('');\n  const [selectedStageId, setSelectedStageId] = useState<string>('');\n  const [amount, setAmount] = useState<string>('');\n  const [personId, setPersonId] = useState<string>('');\n  const [dealSpecificProbability, setDealSpecificProbability] = useState<string>('');\n  const [expectedCloseDate, setExpectedCloseDate] = useState<string>('');\n  \n  // State for Custom Fields\n  const [customFieldFormValues, setCustomFieldFormValues] = useState<Record<string, any>>({}); // Reverted to any\n  const [activeDealCustomFields, setActiveDealCustomFields] = useState<GraphQLCustomFieldDefinition[]>([]);\n\n  const { pipelines, fetchPipelines, pipelinesLoading, pipelinesError } = usePipelinesStore();\n\n  const { \n    stages,\n    fetchStages,\n    stagesLoading,\n    stagesError\n  } = useStagesStore();\n\n  // Custom Field Definitions Store\n  const { \n    definitions: allCustomFieldDefs, \n    fetchCustomFieldDefinitions: fetchDefinitions, \n    loading: customFieldsLoading, \n    error: customFieldsError \n  } = useCustomFieldDefinitionStore();\n\n  const { createDeal: createDealAction, dealsError, dealsLoading } = useDealsStore(); \n\n  const { people, fetchPeople, peopleLoading, peopleError } = usePeopleStore();\n\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const toast = useToast();\n\n  useEffect(() => {\n    if (isOpen) {\n      setName('');\n      setLocalSelectedPipelineId('');\n      setSelectedStageId('');\n      setAmount('');\n      setPersonId('');\n      setError(null);\n      setDealSpecificProbability('');\n      setExpectedCloseDate('');\n      setIsLoading(false);\n      \n      // Reset custom field states\n      setCustomFieldFormValues({});\n      setActiveDealCustomFields([]); // Clear previous active fields\n\n      void fetchPeople(); \n      void fetchPipelines(); \n      // Fetch active custom field definitions for Deals\n      void fetchDefinitions(CustomFieldEntityType.Deal, false);\n    }\n  }, [isOpen, fetchPeople, fetchPipelines, fetchDefinitions]);\n\n  useEffect(() => {\n    // Update activeDealCustomFields when definitions are fetched from the store\n    // We filter here to ensure we only use DEAL definitions and they are active (though fetchDefinitions should handle active state)\n    const activeDealDefs = allCustomFieldDefs.filter(\n      def => def.entityType === CustomFieldEntityType.Deal && def.isActive\n    );\n    setActiveDealCustomFields(activeDealDefs);\n  }, [allCustomFieldDefs]);\n\n  useEffect(() => {\n    // Initialize customFieldFormValues with default values when activeDealCustomFields are loaded\n    const initialCustomValues: Record<string, any> = {}; // Reverted to any\n    activeDealCustomFields.forEach(def => {\n      if (def.fieldType === CustomFieldType.Boolean) {\n        initialCustomValues[def.fieldName] = false;\n      } else if (def.fieldType === CustomFieldType.MultiSelect) {\n        initialCustomValues[def.fieldName] = [];\n      } else {\n        initialCustomValues[def.fieldName] = '';\n      }\n    });\n    setCustomFieldFormValues(initialCustomValues);\n  }, [activeDealCustomFields]);\n\n  useEffect(() => {\n    if (localSelectedPipelineId) {\n        setSelectedStageId('');\n        void fetchStages(localSelectedPipelineId); // Kept void\n    } else {\n        useStagesStore.setState({ stages: [], stagesError: null, stagesLoading: false });\n    }\n  }, [localSelectedPipelineId, fetchStages]);\n\n  const handleSubmit = async (event: React.FormEvent) => {\n    event.preventDefault();\n    setIsLoading(true);\n    setError(null);\n\n    if (!name.trim()) {\n        setError('Deal name is required.');\n        setIsLoading(false);\n        return;\n    }\n    if (!selectedStageId) {\n        setError('Stage selection is required.');\n        setIsLoading(false);\n        return;\n    }\n\n    try {\n      const dealInput: DealInput = {\n        name: name.trim(),\n        stage_id: selectedStageId,\n        pipeline_id: localSelectedPipelineId,\n        amount: amount ? parseFloat(amount) : null,\n        person_id: personId || null,\n        expected_close_date: expectedCloseDate ? new Date(expectedCloseDate).toISOString() : null,\n        // customFields: [] // Initialize customFields array - will be populated below\n      };\n\n      // Populate customFields for submission\n      const customFieldsSubmission: CustomFieldValueInput[] = activeDealCustomFields\n        .map(def => {\n          const rawValue: any = customFieldFormValues[def.fieldName]; \n          \n          const valueInputPayload: Omit<CustomFieldValueInput, 'definitionId'> = {};\n\n          // Skip if the rawValue is undefined or null, unless it's a boolean (which defaults to false)\n          // or an empty array for multi-select (which is a valid empty state).\n          // For empty strings in required text fields, validation should catch it, but we might send it.\n          if (rawValue === undefined || rawValue === null) {\n            if (def.fieldType === CustomFieldType.Boolean) {\n              // Booleans always have a value (true/false)\n              valueInputPayload.booleanValue = false; // Default to false if null/undefined somehow\n            } else if (def.fieldType === CustomFieldType.MultiSelect && Array.isArray(rawValue) && rawValue.length === 0) {\n              valueInputPayload.selectedOptionValues = []; // Send empty array for multi-select\n            } else if (def.isRequired) {\n              // A required field is null/undefined and not a boolean/empty multi-select - this is a validation issue\n              // For now, we'll let it pass and backend validation or GraphQL type system might catch it if we send nothing.\n              // Or, we could return null here to not send this field value at all if it's truly empty for a required field.\n              // Let's try to send what we have, or nothing if truly empty and not boolean/multi-select.\n               if (rawValue === undefined || rawValue === null) return null; // Skip if no value for non-boolean/non-multiselect\n            } else {\n                 // Optional field with no value\n                 return null; \n            }\n          }\n\n          switch (def.fieldType) {\n            case CustomFieldType.Text:\n              valueInputPayload.stringValue = String(rawValue);\n              break;\n            case CustomFieldType.Dropdown: // Single select dropdown\n              valueInputPayload.stringValue = String(rawValue);\n              break;\n            case CustomFieldType.Number: {\n              const num = parseFloat(String(rawValue));\n              if (!isNaN(num)) {\n                valueInputPayload.numberValue = num;\n              } else if (String(rawValue).trim() === '' && !def.isRequired) {\n                // Optional number field, cleared by user, send nothing for this value part\n              } else if (def.isRequired || String(rawValue).trim() !== '') {\n                 console.warn(`Invalid number for required field ${def.fieldName}: ${String(rawValue)}`); // Ensure rawValue is string for template\n                 return null; \n              }\n              break;\n            }\n            case CustomFieldType.Boolean:\n              valueInputPayload.booleanValue = Boolean(rawValue);\n              break;\n            case CustomFieldType.Date:\n              // Ensure YYYY-MM-DD format if that's what your DateTime scalar expects for date-only\n              valueInputPayload.dateValue = String(rawValue); \n              break;\n            case CustomFieldType.MultiSelect:\n              if (Array.isArray(rawValue)) {\n                valueInputPayload.selectedOptionValues = rawValue.map(String);\n              }\n              break;\n            default:\n              console.warn(`Unhandled custom field type: ${String(def.fieldType)} for field ${def.fieldName}`); \n              return null; \n          }\n          \n          // Only return an entry if at least one value field was set in valueInputPayload\n          if (Object.keys(valueInputPayload).length > 0) {\n            return { definitionId: def.id, ...valueInputPayload };\n          }\n          return null; // If no value field was set (e.g. optional empty number)\n        })\n        .filter(cf => cf !== null) as CustomFieldValueInput[]; // Filter out any nulls from map\n      \n      dealInput.customFields = customFieldsSubmission;\n\n      const probPercent = parseFloat(dealSpecificProbability);\n      if (!isNaN(probPercent) && probPercent >= 0 && probPercent <= 100) {\n        dealInput.deal_specific_probability = probPercent / 100;\n      } else if (dealSpecificProbability.trim() === '') {\n        dealInput.deal_specific_probability = null;\n      }\n\n      console.log('Calling createDealAction with input:', dealInput);\n\n      const createdDeal = await createDealAction(dealInput);\n\n      if (createdDeal) {\n        const stageOfCreatedDeal = stages.find(s => s.id === createdDeal.stage_id);\n\n        console.log('Deal created via store action:', createdDeal);\n        toast({\n          title: \"Deal Created\",\n          description: `Deal \"${createdDeal.name}\" created${stageOfCreatedDeal ? ` in stage \"${stageOfCreatedDeal.name}\"` : ''}.`,\n          status: \"success\",\n          duration: 5000,\n          isClosable: true,\n        });\n        onDealCreated();\n        onClose();\n      } else {\n        setError(dealsError || 'Failed to create deal. Please check store errors.');\n      }\n\n    } catch (err: unknown) {\n      console.error('Unexpected error during handleSubmit:', err);\n      let message = 'An unexpected error occurred.';\n      if (err instanceof Error) {\n        message = err.message;\n      } else if (typeof err === 'string') {\n        message = err;\n      }\n      setError(message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleFormSubmitWrapper = (event: React.FormEvent) => {\n    event.preventDefault(); \n    void handleSubmit(event); \n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} isCentered>\n      <ModalOverlay />\n      {/* If ModalContent is the form, onSubmit here. If a <form> tag is inside, then on that <form> */}\n      <ModalContent as=\"form\" onSubmit={handleFormSubmitWrapper}> \n        <ModalHeader>Create New Deal</ModalHeader>\n        <ModalCloseButton />\n        <ModalBody pb={6}>\n          {error && (\n             <Alert status=\"error\" mb={4} whiteSpace=\"pre-wrap\"> \n                <AlertIcon />\n                {error}\n            </Alert>\n          )}\n          {peopleError && (\n             <Alert status=\"warning\" mb={4}>\n                <AlertIcon />\n                {peopleError}\n            </Alert>\n          )}\n          <VStack spacing={4}>\n            <FormControl isRequired isInvalid={!name.trim() && error?.includes('name')}>\n              <FormLabel>Deal Name</FormLabel>\n              <Input \n                placeholder='Enter deal name' \n                value={name}\n                onChange={(e) => setName(e.target.value)}\n              />\n              {error?.toLowerCase().includes('name') && <FormErrorMessage>{error}</FormErrorMessage>}\n            </FormControl>\n\n            {/* Custom Fields Rendering */}\n            {customFieldsLoading && <Spinner label=\"Loading custom fields...\" />}\n            {customFieldsError && <Alert status=\"error\" mb={4}><AlertIcon />Error loading custom fields: {customFieldsError}</Alert>}\n            \n            {activeDealCustomFields.map((def) => (\n              <FormControl key={def.fieldName} isRequired={def.isRequired} mb={4}>\n                <FormLabel htmlFor={def.fieldName}>{def.fieldLabel}</FormLabel>\n                {(() => {\n                  switch (def.fieldType) {\n                    case CustomFieldType.Text:\n                      return (\n                        <Input\n                          id={def.fieldName}\n                          placeholder={def.fieldLabel}\n                          value={customFieldFormValues[def.fieldName] || ''}\n                          onChange={(e) => setCustomFieldFormValues(prev => ({ ...prev, [def.fieldName]: e.target.value }))}\n                        />\n                      );\n                    case CustomFieldType.Number:\n                      return (\n                        <NumberInput\n                          id={def.fieldName}\n                          value={customFieldFormValues[def.fieldName] || ''}\n                          onChange={(valueString) => setCustomFieldFormValues(prev => ({ ...prev, [def.fieldName]: valueString }))}\n                          allowMouseWheel\n                        >\n                          <NumberInputField placeholder={def.fieldLabel} />\n                        </NumberInput>\n                      );\n                    case CustomFieldType.Date:\n                      return (\n                        <Input\n                          id={def.fieldName}\n                          type=\"date\"\n                          value={customFieldFormValues[def.fieldName] || ''}\n                          onChange={(e) => setCustomFieldFormValues(prev => ({ ...prev, [def.fieldName]: e.target.value }))}\n                        />\n                      );\n                    case CustomFieldType.Boolean:\n                      return (\n                        <Switch\n                          id={def.fieldName}\n                          isChecked={customFieldFormValues[def.fieldName] || false}\n                          onChange={(e) => setCustomFieldFormValues(prev => ({ ...prev, [def.fieldName]: e.target.checked }))}\n                        />\n                      );\n                    case CustomFieldType.Dropdown:\n                      return (\n                        <Select\n                          id={def.fieldName}\n                          placeholder={`Select ${def.fieldLabel}...`}\n                          value={customFieldFormValues[def.fieldName] || ''}\n                          onChange={(e) => setCustomFieldFormValues(prev => ({ ...prev, [def.fieldName]: e.target.value }))}\n                        >\n                          {def.dropdownOptions?.map(opt => (\n                            <option key={opt.value} value={opt.value}>{opt.label}</option>\n                          ))}\n                        </Select>\n                      );\n                    case CustomFieldType.MultiSelect:\n                      return (\n                        <CheckboxGroup \n                          value={customFieldFormValues[def.fieldName] || []} \n                          onChange={(values) => setCustomFieldFormValues(prev => ({ ...prev, [def.fieldName]: values }))}\n                        >\n                          <Stack direction=\"column\">\n                            {def.dropdownOptions?.map(opt => (\n                              <Checkbox key={opt.value} value={opt.value}>{opt.label}</Checkbox>\n                            ))}\n                          </Stack>\n                        </CheckboxGroup>\n                      );\n                    default:\n                      return <Text color=\"red\">Unsupported field type: {def.fieldType}</Text>;\n                  }\n                })()}\n                {(() => {\n                  const fieldValue = customFieldFormValues[def.fieldName];\n                  if (def.isRequired && \n                    (!fieldValue || \n                      (Array.isArray(fieldValue) && fieldValue.length === 0) || \n                      (typeof fieldValue === 'string' && fieldValue.trim() === '')\n                    )\n                  ) {\n                    return <Text fontSize=\"sm\" color=\"red.500\" mt={1}>This field is required.</Text>;\n                  }\n                  return null;\n                })()}\n              </FormControl>\n            ))}\n\n            <FormControl isRequired isInvalid={!localSelectedPipelineId && error?.toLowerCase().includes('pipeline')}>\n              <FormLabel>Pipeline</FormLabel>\n              <Select \n                placeholder={pipelinesLoading ? 'Loading pipelines...' : 'Select pipeline'}\n                value={localSelectedPipelineId}\n                onChange={(e) => setLocalSelectedPipelineId(e.target.value)}\n                isDisabled={pipelinesLoading || !!pipelinesError}\n              >\n                 {!pipelinesLoading && !pipelinesError && pipelines.map((pipeline: Pipeline) => (\n                    <option key={pipeline.id} value={pipeline.id}>\n                        {pipeline.name}\n                    </option>\n                ))}\n              </Select>\n              {pipelinesError && <FormErrorMessage>Error loading pipelines: {pipelinesError}</FormErrorMessage>}\n              {!localSelectedPipelineId && error?.toLowerCase().includes('pipeline') && <FormErrorMessage>{error}</FormErrorMessage>}\n            </FormControl>\n\n            <FormControl isRequired isInvalid={!selectedStageId && error?.toLowerCase().includes('stage')}>\n              <FormLabel>Stage</FormLabel>\n              <Select \n                placeholder={stagesLoading ? 'Loading stages...' : (localSelectedPipelineId ? 'Select stage' : 'Select pipeline first') }\n                value={selectedStageId}\n                onChange={(e) => setSelectedStageId(e.target.value)}\n                isDisabled={!localSelectedPipelineId || stagesLoading || !!stagesError || stages.length === 0}\n              >\n                 {!stagesLoading && !stagesError && stages.map((stage: Stage) => (\n                    <option key={stage.id} value={stage.id}>\n                        {stage.name} (Order: {stage.order})\n                    </option>\n                ))}\n              </Select>\n              {stagesError && <FormErrorMessage>Error loading stages: {stagesError}</FormErrorMessage>}\n              {!localSelectedPipelineId && stages.length === 0 && !stagesLoading && <FormErrorMessage>Select a pipeline to see stages.</FormErrorMessage>}\n              {!selectedStageId && error?.toLowerCase().includes('stage') && <FormErrorMessage>{error}</FormErrorMessage>}\n            </FormControl>\n\n            <FormControl>\n              <FormLabel>Amount</FormLabel>\n              <NumberInput value={amount} onChange={(valueString) => setAmount(valueString)} precision={2}>\n                <NumberInputField id='amount' placeholder='e.g., 5000.00' />\n              </NumberInput>\n            </FormControl>\n\n            <FormControl mt={4}>\n              <FormLabel htmlFor='expected_close_date'>Expected Close Date</FormLabel>\n              <Input \n                id='expected_close_date'\n                type='date' \n                value={expectedCloseDate}\n                onChange={(e) => setExpectedCloseDate(e.target.value)}\n              />\n            </FormControl>\n\n            <FormControl>\n              <FormLabel>Deal Specific Probability (%)</FormLabel>\n              <NumberInput\n                min={0}\n                max={100}\n                value={dealSpecificProbability}\n                onChange={(valueString) => setDealSpecificProbability(valueString)}\n                allowMouseWheel\n              >\n                <NumberInputField placeholder=\"Optional (e.g., 75)\" />\n              </NumberInput>\n            </FormControl>\n\n            <FormControl>\n              <FormLabel>Link to Person (Optional)</FormLabel>\n              <Select \n                placeholder={peopleLoading ? 'Loading people...' : 'Select person'}\n                value={personId}\n                onChange={(e) => setPersonId(e.target.value)}\n                isDisabled={peopleLoading || !!peopleError}\n              >\n                 {!peopleLoading && !peopleError && people.map((person: Person) => (\n                    <option key={person.id} value={person.id}>\n                        {[person.first_name, person.last_name].filter(Boolean).join(' ') || person.email || `Person ID: ${person.id}`}\n                    </option>\n                ))}\n              </Select>\n            </FormControl>\n\n          </VStack>\n        </ModalBody>\n\n        <ModalFooter>\n          <Button \n            colorScheme='blue'\n            mr={3} \n            type=\"submit\" // Make button type submit if it's for the form\n            isLoading={isLoading || dealsLoading}\n            leftIcon={(isLoading || dealsLoading) ? <Spinner size=\"sm\" /> : undefined}\n          >\n            Save Deal\n          </Button>\n          <Button variant='ghost' onClick={onClose} isDisabled={isLoading}>\n            Cancel\n          </Button>\n        </ModalFooter>\n      </ModalContent>\n    </Modal>\n  );\n}\n\nexport default CreateDealModal; ","usedDeprecatedRules":[]}]