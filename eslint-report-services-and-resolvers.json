[{"filePath":"/Users/tomaskovarik/059_PIPECD/PIPECD/lib/teamService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[558,561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[558,561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[906,909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[906,909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1399,1402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1399,1402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2511,2514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2511,2514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3228,3231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3228,3231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4164,4167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4164,4167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4719,4722],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4719,4722],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4843,4846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4843,4846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6226,6229],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6226,6229],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6653,6656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6653,6656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":237,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7621,7624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7621,7624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SupabaseClient } from '@supabase/supabase-js';\n// import { Database } from './database.types'; // Will be used once database.types.ts is updated\n// import { getAuthenticatedClient } from './serviceUtils'; // Assuming serviceUtils is in lib/\n// import { User } from './generated/graphql'; // For types if needed directly, or use DB types\n\n// Define a type for the database Team row if not already in database.types.ts\n// For now, we'll assume it can be inferred or use 'any'/'Record<string,any>' and refine later.\nexport type DbTeam = Record<string, any>; // Placeholder\n\n/**\n * Fetches a single team by its ID.\n * Relies on RLS for row-level security.\n * \n * @param supabase The Supabase client instance (typed as any for now).\n * @param teamId The ID of the team to fetch.\n * @returns The team object or null if not found/permitted.\n */\nexport const getTeamById = async (supabase: SupabaseClient<any>, teamId: string): Promise<DbTeam | null> => {\n  const { data: dbTeam, error } = await supabase\n    .from('teams') // This will work once database.types.ts is correct\n    .select('*')\n    .eq('id', teamId)\n    .single();\n\n  if (error) {\n    console.error(`teamService.getTeamById: Error fetching team ${teamId}: ${error.message}`);\n    if (error.code === 'PGRST116') return null; \n    throw error; \n  }\n  return dbTeam;\n};\n\nexport const createTeamInDb = async (\n  supabase: SupabaseClient<any>, \n  input: { name: string; description?: string | null; teamLeadUserId?: string | null },\n  creatorUserId: string\n): Promise<DbTeam> => {\n  const { data: newDbTeam, error } = await supabase\n    .from('teams')\n    .insert({ \n      name: input.name, \n      description: input.description, \n      team_lead_user_id: input.teamLeadUserId, \n      created_by_user_id: creatorUserId \n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(`teamService.createTeamInDb: Error creating team - ${error.message}`);\n    // Example: check for unique constraint violation on name if needed\n    // if (error.code === '23505') throw new Error('Team name already exists.');\n    throw error; \n  }\n  if (!newDbTeam) { \n    console.error('teamService.createTeamInDb: No data returned after insert, though no error reported.');\n    throw new Error('Team creation failed to return data.');\n  }\n  return newDbTeam;\n};\n\ninterface TeamsFilter { \n  // e.g. nameContains?: string;\n}\n\ninterface Pagination {\n  limit?: number | null;\n  offset?: number | null;\n}\n\nexport const getTeams = async (\n  supabase: SupabaseClient<any>,\n  filter?: TeamsFilter | null, \n  pagination?: Pagination | null\n): Promise<DbTeam[]> => {\n  let query = supabase.from('teams').select('*');\n\n  // if (filter?.nameContains) { // Placeholder for actual filter logic\n  //   query = query.ilike('name', `%${filter.nameContains}%`);\n  // }\n\n  if (pagination) {\n    const limit = pagination.limit ?? 20;\n    const offset = pagination.offset ?? 0;\n    query = query.range(offset, offset + limit - 1);\n  }\n\n  const { data: dbTeams, error } = await query;\n\n  if (error) {\n    console.error(`teamService.getTeams: Error fetching teams: ${error.message}`);\n    throw error;\n  }\n  return dbTeams || [];\n};\n\nexport const getTeamsForUser = async (\n  supabase: SupabaseClient<any>,\n  userId: string\n): Promise<DbTeam[]> => {\n  // Fetch team_ids the user is a member of\n  const { data: teamMembers, error: tmError } = await supabase\n    .from('team_members')\n    .select('team_id')\n    .eq('user_id', userId);\n\n  if (tmError) {\n    console.error(`teamService.getTeamsForUser: Error fetching team memberships for user ${userId}:`, tmError.message);\n    throw tmError;\n  }\n\n  if (!teamMembers || teamMembers.length === 0) {\n    return [];\n  }\n\n  const teamIds = teamMembers.map(tm => tm.team_id);\n\n  const { data: teamsData, error: teamsError } = await supabase\n    .from('teams')\n    .select('*')\n    .in('id', teamIds);\n\n  if (teamsError) {\n    console.error(`teamService.getTeamsForUser: Error fetching teams for user ${userId} with IDs [${teamIds.join(',')}] :`, teamsError.message);\n    throw teamsError;\n  }\n  \n  return teamsData || [];\n};\n\nexport const getTeamsLedByUser = async (\n  supabase: SupabaseClient<any>,\n  userId: string\n): Promise<DbTeam[]> => {\n  const { data: ledTeamsData, error } = await supabase\n    .from('teams')\n    .select('*')\n    .eq('team_lead_user_id', userId);\n  \n  if (error) {\n    console.error(`teamService.getTeamsLedByUser: Error fetching teams led by user ${userId}:`, error.message);\n    throw error;\n  }\n\n  return ledTeamsData || [];\n};\n\nexport type UpdateTeamDbInput = {\n  name?: string | null;\n  description?: string | null;\n  teamLeadUserId?: string | null;\n};\n\nexport const updateTeamInDb = async (\n  supabase: SupabaseClient<any>,\n  teamId: string,\n  updatePayload: UpdateTeamDbInput \n): Promise<DbTeam> => {\n  const dbUpdatePayload: Record<string, any> = {};\n  if (updatePayload.name !== undefined) dbUpdatePayload.name = updatePayload.name;\n  if (updatePayload.description !== undefined) dbUpdatePayload.description = updatePayload.description;\n  if (updatePayload.teamLeadUserId !== undefined) dbUpdatePayload.team_lead_user_id = updatePayload.teamLeadUserId;\n\n  if (Object.keys(dbUpdatePayload).length === 0) {\n    console.warn('teamService.updateTeamInDb: Called with empty updatePayload. Fetching and returning existing team.');\n    const existingTeam = await getTeamById(supabase, teamId);\n    if (!existingTeam) throw new Error(`Team with ID ${teamId} not found for no-op update.`);\n    return existingTeam;\n  }\n\n  const { data: updatedDbTeam, error } = await supabase\n    .from('teams')\n    .update(dbUpdatePayload)\n    .eq('id', teamId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(`teamService.updateTeamInDb: Error updating team ${teamId}: ${error.message}`);\n    if (error.code === 'PGRST116') { \n      throw new Error(`Team with ID ${teamId} not found or not permitted to update.`); \n    }\n    throw error;\n  }\n  if (!updatedDbTeam) {\n    console.error('teamService.updateTeamInDb: No data returned after update, though no error reported.');\n    throw new Error('Team update failed to return data.');\n  }\n  return updatedDbTeam;\n};\n\nexport const deleteTeamFromDb = async (\n  supabase: SupabaseClient<any>,\n  teamId: string\n): Promise<{ success: boolean; count: number | null }> => {\n  const { error, count } = await supabase\n    .from('teams')\n    .delete()\n    .eq('id', teamId);\n\n  if (error) {\n    console.error(`teamService.deleteTeamFromDb: Error deleting team ${teamId}: ${error.message}`);\n    throw error; \n  }\n  return { success: true, count }; \n};\n\nexport const addTeamMemberToDb = async (\n  supabase: SupabaseClient<any>,\n  teamId: string,\n  userId: string,\n  role?: string | null \n): Promise<{ team_id: string; user_id: string; role?: string | null }> => {\n  const insertPayload: { team_id: string; user_id: string; role?: string } = { team_id: teamId, user_id: userId };\n  if (role) {\n    insertPayload.role = role;\n  }\n\n  const { data: newMemberLink, error } = await supabase\n    .from('team_members')\n    .insert(insertPayload)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(`teamService.addTeamMemberToDb: Error adding user ${userId} to team ${teamId}: ${error.message}`);\n    throw error;\n  }\n  if (!newMemberLink) {\n    console.error('teamService.addTeamMemberToDb: No data returned after insert, though no error reported.');\n    throw new Error('Team member creation failed to return data.');\n  }\n  return newMemberLink as { team_id: string; user_id: string; role?: string | null };\n};\n\nexport const removeTeamMemberFromDb = async (\n  supabase: SupabaseClient<any>,\n  teamId: string,\n  userId: string\n): Promise<{ success: boolean; count: number | null }> => {\n  const { error, count } = await supabase\n    .from('team_members')\n    .delete()\n    .match({ team_id: teamId, user_id: userId });\n\n  if (error) {\n    console.error(`teamService.removeTeamMemberFromDb: Error removing user ${userId} from team ${teamId}: ${error.message}`);\n    throw error;\n  }\n  return { success: true, count };\n};\n\n// Add more service functions here... ","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/tomaskovarik/059_PIPECD/PIPECD/netlify/functions/graphql/resolvers/teamResolvers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CreateTeamInput' is defined but never used.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UpdateTeamInput' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PaginationInput' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1328,1331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1328,1331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2534,2537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2534,2537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4045,4048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4045,4048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4793,4796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4793,4796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":120,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5579,5582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5579,5582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6804,6807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6804,6807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8854,8857],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8854,8857],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9655,9658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9655,9658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is assigned a value but never used.","line":208,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":208,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10933,10936],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10933,10936],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12600,12603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12600,12603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is assigned a value but never used.","line":268,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":268,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":290,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14867,14870],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14867,14870],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Resolvers,\n  Team as GraphQLTeam,\n  User as GraphQLUser,\n  CreateTeamInput,\n  UpdateTeamInput,\n  PaginationInput,\n  QueryTeamArgs,\n  QueryTeamsArgs,\n  MutationCreateTeamArgs,\n  MutationUpdateTeamArgs,\n  MutationDeleteTeamArgs,\n  MutationAddTeamMemberArgs,\n  MutationRemoveTeamMemberArgs\n} from '../../../../lib/generated/graphql';\nimport { GraphQLError } from 'graphql';\nimport { GraphQLContext } from '../index';\nimport * as teamService from '../../../../lib/teamService'; // Import the new service\n\n// Helper to get current user ID, throwing error if not authenticated\nconst getCurrentUserId = (context: GraphQLContext): string => {\n  if (!context.currentUser?.id) {\n    throw new GraphQLError('User is not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });\n  }\n  return context.currentUser.id;\n};\n\n// Helper to map DB team row to GraphQLTeam (excluding relational fields handled by field resolvers)\n// Exported for use in other resolvers like userResolvers.ts\nexport const mapDbTeamToGraphQLTeam = (dbTeam: unknown): (Partial<GraphQLTeam> & { _team_lead_user_id?: string, _created_by_user_id?: string }) | null => {\n  if (!dbTeam || typeof dbTeam !== 'object') return null;\n  // Type guard or assertion might be needed if accessing properties directly on unknown\n  const team = dbTeam as Record<string, any>; // Assert to access properties\n\n  return {\n    id: team.id,\n    name: team.name,\n    description: team.description,\n    createdAt: team.created_at, // Ensure DateTime scalar handles string conversion, map to camelCase\n    updatedAt: team.updated_at, // Map to camelCase\n    // Fields to be resolved by Team field resolvers:\n    // teamLead (based on team.team_lead_user_id)\n    // members (based on team.id)\n    // createdBy (based on team.created_by_user_id)\n\n    // Store these raw IDs on the object for field resolvers to use\n    _team_lead_user_id: team.team_lead_user_id,\n    _created_by_user_id: team.created_by_user_id,\n  };\n}\n\nexport const teamResolvers: Resolvers<GraphQLContext> = {\n  Query: {\n    team: async (_parent: unknown, args: QueryTeamArgs, context: GraphQLContext): Promise<GraphQLTeam | null> => {\n      const { supabase } = context; // Supabase client from context\n      const { id } = args;\n      try {\n        const dbTeam = await teamService.getTeamById(supabase, id);\n        // mapDbTeamToGraphQLTeam can return null if dbTeam is null, which is fine for a nullable GQL return type.\n        return mapDbTeamToGraphQLTeam(dbTeam) as GraphQLTeam | null;\n      } catch (error: any) {\n        // Log the original error from the service, but return a generic GQL error\n        console.error(`Resolver Query.team: Error fetching team ${id}: ${error.message}`);\n        // Avoid exposing detailed service/database errors to the client directly\n        throw new GraphQLError('Could not fetch team.', { \n          extensions: { code: 'INTERNAL_SERVER_ERROR' },\n          originalError: error // Optionally include original error for server-side logging or debugging\n        });\n      }\n    },\n    teams: async (_parent: unknown, args: QueryTeamsArgs, context: GraphQLContext): Promise<GraphQLTeam[]> => {\n      const { supabase } = context;\n      const { filter, pagination } = args;\n\n      try {\n        // The filter from QueryTeamsArgs (TeamsFilterInput) currently only has a placeholder.\n        // If actual filter fields are added to TeamsFilterInput, teamService.getTeams would need to handle them.\n        const dbTeams = await teamService.getTeams(supabase, filter, pagination);\n        \n        // Filter out nulls that mapDbTeamToGraphQLTeam might produce if a team record is problematic,\n        // although getTeams service function already returns DbTeam[] so individual items shouldn't be null.\n        // The as GraphQLTeam cast assumes mapDbTeamToGraphQLTeam successfully maps or returns null (filtered out).\n        return dbTeams\n          .map(dbTeam => mapDbTeamToGraphQLTeam(dbTeam))\n          .filter(gqlTeam => gqlTeam !== null) as GraphQLTeam[];\n      } catch (error: any) {\n        console.error(`Resolver Query.teams: Error fetching teams - ${error.message}`);\n        throw new GraphQLError('Could not fetch teams.', { \n          extensions: { code: 'INTERNAL_SERVER_ERROR' },\n          originalError: error \n        });\n      }\n    },\n    myTeams: async (_parent: unknown, _args: Record<string, never>, context: GraphQLContext): Promise<GraphQLTeam[]> => {\n      const currentUserId = getCurrentUserId(context);\n      const { supabase } = context;\n\n      try {\n        const dbTeams = await teamService.getTeamsForUser(supabase, currentUserId);\n        return dbTeams\n          .map(dbTeam => mapDbTeamToGraphQLTeam(dbTeam))\n          .filter(gqlTeam => gqlTeam !== null) as GraphQLTeam[];\n      } catch (error: any) {\n        console.error(`Resolver Query.myTeams: Error fetching teams for user ${currentUserId} - ${error.message}`);\n        throw new GraphQLError('Could not fetch user teams.', { \n          extensions: { code: 'INTERNAL_SERVER_ERROR' },\n          originalError: error \n        });\n      }\n    },\n    myLedTeams: async (_parent: unknown, _args: Record<string, never>, context: GraphQLContext): Promise<GraphQLTeam[]> => {\n      const currentUserId = getCurrentUserId(context);\n      const { supabase } = context;\n\n      try {\n        const dbTeams = await teamService.getTeamsLedByUser(supabase, currentUserId);\n        return dbTeams\n          .map(dbTeam => mapDbTeamToGraphQLTeam(dbTeam))\n          .filter(gqlTeam => gqlTeam !== null) as GraphQLTeam[];\n      } catch (error: any) {\n        console.error(`Resolver Query.myLedTeams: Error fetching teams led by user ${currentUserId} - ${error.message}`);\n        throw new GraphQLError('Could not fetch teams led by user.', { \n          extensions: { code: 'INTERNAL_SERVER_ERROR' },\n          originalError: error \n        });\n      }\n    }\n  },\n  Mutation: {\n    createTeam: async (_parent: unknown, args: MutationCreateTeamArgs, context: GraphQLContext): Promise<GraphQLTeam> => {\n      const currentUserId = getCurrentUserId(context);\n      const { supabase } = context; // Supabase client from context\n      const { input } = args;\n\n      try {\n        const dbTeam = await teamService.createTeamInDb(supabase, input, currentUserId);\n        \n        const gqlTeam = mapDbTeamToGraphQLTeam(dbTeam);\n        if (!gqlTeam) {\n          // This case should ideally be caught by the service if dbTeam comes back unexpectedly null\n          console.error('Resolver Mutation.createTeam: dbTeam mapped to null, but schema expects non-null Team.');\n          throw new GraphQLError('Failed to process team details after creation.', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });\n        }\n        return gqlTeam as GraphQLTeam;\n      } catch (error: any) {\n        console.error(`Resolver Mutation.createTeam: Error creating team - ${error.message}`);\n        // Check for specific errors thrown by the service if needed, e.g., unique name violation\n        // if (error.message.includes('Team name already exists')) {\n        //   throw new GraphQLError('A team with this name already exists.', { extensions: { code: 'BAD_USER_INPUT' }});\n        // }\n        throw new GraphQLError('Could not create team.', { \n          extensions: { code: 'INTERNAL_SERVER_ERROR' }, \n          originalError: error \n        });\n      }\n    },\n    updateTeam: async (_parent: unknown, args: MutationUpdateTeamArgs, context: GraphQLContext): Promise<GraphQLTeam> => {\n      getCurrentUserId(context); \n      const { supabase } = context;\n      const { id, ...updateInput } = args.input; // Destructure id and the rest of the input fields\n\n      // The GQL input UpdateTeamInput has: id: ID!, name: String, description: String, teamLeadUserId: ID\n      // The service expects: name?: string | null; description?: string | null; teamLeadUserId?: string | null;\n      // So, the 'updateInput' directly matches what the service expects for its payload.\n      \n      if (Object.keys(updateInput).length === 0) {\n        // GQL layer check for no actual update fields being provided besides ID.\n        // The service also has a check, but it's good to catch earlier.\n        // We need to return a GraphQLTeam, so fetch the current one if no updates.\n        try {\n          const dbTeam = await teamService.getTeamById(supabase, id);\n          if (!dbTeam) {\n            throw new GraphQLError('Team not found for no-op update.', { extensions: { code: 'NOT_FOUND' }});\n          }\n          const gqlTeam = mapDbTeamToGraphQLTeam(dbTeam);\n          if (!gqlTeam) {\n            throw new GraphQLError('Failed to process existing team details.', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });\n          }\n          return gqlTeam as GraphQLTeam; // Return current team if no fields to update\n        } catch (error: any) {\n          console.error(`Resolver Mutation.updateTeam (no-op path): Error fetching team ${id} - ${error.message}`);\n          throw new GraphQLError('Could not process update request.', { extensions: { code: 'INTERNAL_SERVER_ERROR' }, originalError: error });\n        }\n      }\n\n      try {\n        const updatedDbTeam = await teamService.updateTeamInDb(supabase, id, updateInput);\n        const gqlTeam = mapDbTeamToGraphQLTeam(updatedDbTeam);\n        if (!gqlTeam) {\n          console.error(`Resolver Mutation.updateTeam: updatedDbTeam (${id}) mapped to null, schema expects non-null.`);\n          throw new GraphQLError('Failed to process team details after update.', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });\n        }\n        return gqlTeam as GraphQLTeam;\n      } catch (error: any) {\n        console.error(`Resolver Mutation.updateTeam: Error updating team ${id} - ${error.message}`);\n        if (error.message?.includes('not found or not permitted')) {\n          throw new GraphQLError('Team not found or update not permitted.', { extensions: { code: 'NOT_FOUND' }, originalError: error });\n        }\n        throw new GraphQLError('Could not update team.', { extensions: { code: 'INTERNAL_SERVER_ERROR' }, originalError: error });\n      }\n    },\n    deleteTeam: async (_parent: unknown, args: MutationDeleteTeamArgs, context: GraphQLContext): Promise<boolean> => {\n      getCurrentUserId(context);\n      const { supabase } = context;\n      const { id } = args;\n\n      try {\n        const { count } = await teamService.deleteTeamFromDb(supabase, id);\n        // If count is 0, it might mean the team was not found or RLS prevented deletion.\n        // The GraphQL schema expects a boolean. We'll return true if no error, \n        // assuming the service throws for actual DB errors.\n        // For a stricter check, one might throw if count === 0:\n        // if (count === 0) {\n        //   throw new GraphQLError('Team not found or could not be deleted.', { extensions: { code: 'NOT_FOUND' } });\n        // }\n        return true; \n      } catch (error: any) {\n        console.error(`Resolver Mutation.deleteTeam: Error deleting team ${id} - ${error.message}`);\n        throw new GraphQLError('Could not delete team.', { \n          extensions: { code: 'INTERNAL_SERVER_ERROR' }, \n          originalError: error \n        });\n      }\n    },\n    addTeamMember: async (_parent: unknown, args: MutationAddTeamMemberArgs, context: GraphQLContext): Promise<GraphQLTeam> => {\n      getCurrentUserId(context); // Ensures an authenticated user is making the request\n      const { supabase } = context;\n      const { teamId, userId } = args; // Role removed as it's not in GQL args\n\n      try {\n        await teamService.addTeamMemberToDb(supabase, teamId, userId); // Role removed from call\n\n        // After successfully adding, refetch the team to return its updated state\n        const dbTeam = await teamService.getTeamById(supabase, teamId);\n        if (!dbTeam) {\n          // This would be an unexpected state if add was successful but team not found immediately after\n          console.error(`Resolver addTeamMember: Team ${teamId} not found after adding member ${userId}.`);\n          throw new GraphQLError('Team not found after adding member.', { extensions: { code: 'NOT_FOUND' } });\n        }\n\n        const gqlTeam = mapDbTeamToGraphQLTeam(dbTeam);\n        if (!gqlTeam) {\n          console.error(`Resolver addTeamMember: dbTeam (${teamId}) mapped to null after adding member, schema expects non-null.`);\n          throw new GraphQLError('Failed to process team details after adding member.', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });\n        }\n        return gqlTeam as GraphQLTeam;\n\n      } catch (error: any) {\n        console.error(`Resolver addTeamMember: Error adding user ${userId} to team ${teamId} - ${error.message}`);\n        if (error.code === '23505') { // unique_violation from Supabase/Postgres\n          throw new GraphQLError('User is already a member of this team.', { extensions: { code: 'BAD_USER_INPUT' } });\n        } else if (error.code === '23503') { // foreign_key_violation\n          throw new GraphQLError('Team or User not found.', { extensions: { code: 'NOT_FOUND' } });\n        }\n        // Generic error for other cases\n        throw new GraphQLError('Could not add member to team.', { \n          extensions: { code: 'INTERNAL_SERVER_ERROR' }, \n          originalError: error \n        });\n      }\n    },\n    removeTeamMember: async (_parent: unknown, args: MutationRemoveTeamMemberArgs, context: GraphQLContext): Promise<GraphQLTeam> => {\n      getCurrentUserId(context);\n      const { supabase } = context;\n      const { teamId, userId } = args;\n\n      try {\n        const { count } = await teamService.removeTeamMemberFromDb(supabase, teamId, userId);\n\n        // if (count === 0) {\n        //   // User might not have been a member, or RLS prevented delete. \n        //   // Depending on desired behavior, could throw an error here or proceed to fetch team.\n        //   console.warn(`Resolver removeTeamMember: No member link found/deleted for user ${userId} in team ${teamId}.`);\n        // }\n\n        // After successfully (or no-op) removing, refetch the team\n        const dbTeam = await teamService.getTeamById(supabase, teamId);\n        if (!dbTeam) {\n          console.error(`Resolver removeTeamMember: Team ${teamId} not found after attempting to remove member ${userId}.`);\n          throw new GraphQLError('Team not found after removing member.', { extensions: { code: 'NOT_FOUND' } });\n        }\n\n        const gqlTeam = mapDbTeamToGraphQLTeam(dbTeam);\n        if (!gqlTeam) {\n          console.error(`Resolver removeTeamMember: dbTeam (${teamId}) mapped to null after removing member, schema expects non-null.`);\n          throw new GraphQLError('Failed to process team details after removing member.', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });\n        }\n        return gqlTeam as GraphQLTeam;\n\n      } catch (error: any) {\n        console.error(`Resolver removeTeamMember: Error removing user ${userId} from team ${teamId} - ${error.message}`);\n        // No specific error codes like 23505 (unique) or 23503 (fk) are typically expected for a successful delete that finds no rows.\n        // If the service throws an actual DB error, it will be caught here.\n        throw new GraphQLError('Could not remove member from team.', { \n          extensions: { code: 'INTERNAL_SERVER_ERROR' }, \n          originalError: error \n        });\n      }\n    },\n  },\n  Team: {\n    teamLead: async (parentTeam: Partial<GraphQLTeam> & { _team_lead_user_id?: string }, _args: Record<string, never>, context: GraphQLContext): Promise<GraphQLUser | null> => {\n      const teamLeadUserId = parentTeam._team_lead_user_id;\n      if (!teamLeadUserId) return null;\n      const { supabase } = context;\n      const { data: userData, error } = await supabase\n        .from('user_profiles') // Assuming user profiles table\n        .select('user_id, display_name, avatar_url, email')\n        .eq('user_id', teamLeadUserId)\n        .single();\n      if (error || !userData) {\n        console.error(`Error fetching team lead profile ${teamLeadUserId}: ${error?.message}`);\n        return null;\n      }\n      return { id: userData.user_id, display_name: userData.display_name, avatar_url: userData.avatar_url, email: userData.email } as GraphQLUser;\n    },\n    members: async (parentTeam: Pick<GraphQLTeam, 'id'>, _args: Record<string, never>, context: GraphQLContext): Promise<GraphQLUser[]> => {\n      const { supabase } = context;\n      const { data: memberLinks, error: memberError } = await supabase\n        .from('team_members')\n        .select('user_id, role') \n        .eq('team_id', parentTeam.id);\n\n      if (memberError) {\n        console.error(`Error fetching members for team ${parentTeam.id}: ${memberError.message}`);\n        return [];\n      }\n      if (!memberLinks || memberLinks.length === 0) return [];\n\n      const userIds = memberLinks.map(ml => ml.user_id);\n      const { data: usersData, error: usersError } = await supabase\n        .from('user_profiles') \n        .select('user_id, display_name, avatar_url, email')\n        .in('user_id', userIds);\n\n      if (usersError) {\n        console.error(`Error fetching member profiles for team ${parentTeam.id}: ${usersError.message}`);\n        return [];\n      }\n      return usersData ? usersData.map(u => ({\n          id: u.user_id,\n          email: u.email || `${u.user_id.substring(0,8)}@placeholder.email`, \n          display_name: u.display_name,\n          avatar_url: u.avatar_url,\n        } as GraphQLUser) \n      ) : [];\n    },\n    createdBy: async (parentTeam: Partial<GraphQLTeam> & { _created_by_user_id?: string }, _args: Record<string, never>, context: GraphQLContext): Promise<GraphQLUser | null> => {\n      const createdByUserId = parentTeam._created_by_user_id;\n      if (!createdByUserId) return null;\n      const { supabase } = context;\n      const { data: userData, error } = await supabase\n        .from('user_profiles') \n        .select('user_id, display_name, avatar_url, email')\n        .eq('user_id', createdByUserId)\n        .single();\n      if (error || !userData) {\n        console.error(`Error fetching creator profile ${createdByUserId}: ${error?.message}`);\n        return null;\n      }\n      return { id: userData.user_id, display_name: userData.display_name, avatar_url: userData.avatar_url, email: userData.email } as GraphQLUser;\n    },\n  },\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]