[{"filePath":"/Users/tomaskovarik/059_PIPECD/PIPECD/netlify/functions/graphql/resolvers/mutations/dealMutations.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GraphQLDealUpdateInput' is defined but never used.","line":6,"column":105,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":127},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1972,1975],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1972,1975],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pipeline_id' is assigned a value but never used.","line":74,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GraphQLError } from 'graphql';\nimport { GraphQLContext, requireAuthentication, getAccessToken, processZodError, convertToDateOrNull } from '../../helpers'; // convertToDateOrNull imported here\nimport { DealCreateSchema, DealUpdateSchema } from '../../validators';\nimport { inngest } from '../../../../../lib/inngestClient';\nimport { dealService } from '../../../../../lib/dealService';\nimport type { MutationResolvers, Deal as GraphQLDeal, DealInput as GraphQLDealInput, DealUpdateInput as GraphQLDealUpdateInput, MutationReassignDealArgs } from '../../../../../lib/generated/graphql';\n\nexport const dealMutations: Pick<MutationResolvers<GraphQLContext>, 'createDeal' | 'updateDeal' | 'deleteDeal' | 'reassignDeal'> = {\n    createDeal: async (_parent, args, context) => {\n      const action = 'creating deal';\n      try {\n          requireAuthentication(context);\n          const userId = context.currentUser!.id;\n          const accessToken = getAccessToken(context)!;\n\n          const validatedInput = DealCreateSchema.parse(args.input);\n          if (!context.userPermissions?.includes('deal:create')) {\n               throw new GraphQLError('Forbidden', { extensions: { code: 'FORBIDDEN' } });\n          }\n\n          // Ensure customFields is an array or undefined before passing to service\n          const customFieldsForService = Array.isArray(validatedInput.customFields) \n            ? validatedInput.customFields \n            : undefined;\n\n          const serviceInput = {\n            ...validatedInput,\n            expected_close_date: convertToDateOrNull(validatedInput.expected_close_date),\n            customFields: customFieldsForService, // Use the processed customFields\n          };\n\n          const newDealRecord = await dealService.createDeal(userId, serviceInput as GraphQLDealInput, accessToken); // Cast to GraphQLDealInput\n          \n          inngest.send({\n            name: 'crm/deal.created',\n            data: { deal: newDealRecord as any }, \n            user: { id: userId, email: context.currentUser!.email! }\n          }).catch((err: unknown) => console.error('Failed to send deal.created event to Inngest:', err));\n\n          return {\n            id: newDealRecord.id,\n            user_id: newDealRecord.user_id!,\n            created_at: newDealRecord.created_at,\n            updated_at: newDealRecord.updated_at,\n            name: newDealRecord.name!,\n            amount: newDealRecord.amount,\n            expected_close_date: newDealRecord.expected_close_date instanceof Date \n              ? newDealRecord.expected_close_date.toISOString() \n              : newDealRecord.expected_close_date,\n            stage_id: newDealRecord.stage_id!,\n            person_id: newDealRecord.person_id,\n            organization_id: newDealRecord.organization_id,\n            deal_specific_probability: newDealRecord.deal_specific_probability,\n          } as GraphQLDeal;\n      } catch (error) {\n          throw processZodError(error, action);\n      }\n    },\n    updateDeal: async (_parent, args, context) => {\n      const action = 'updating deal';\n      try {\n          requireAuthentication(context);\n          const userId = context.currentUser!.id;\n          const accessToken = getAccessToken(context)!;\n\n          const validatedInput = DealUpdateSchema.parse(args.input);\n          if (!context.userPermissions?.includes('deal:update_any')) {\n               throw new GraphQLError('Forbidden', { extensions: { code: 'FORBIDDEN' } });\n          }\n          if (Object.keys(validatedInput).length === 0) {\n            throw new GraphQLError('Update input cannot be empty.', { extensions: { code: 'BAD_USER_INPUT' } });\n          }\n\n          const { pipeline_id, ...dealDataFromZod } = validatedInput;\n          \n          // Ensure customFields is an array or undefined\n          const customFieldsForService = Array.isArray(dealDataFromZod.customFields) \n            ? dealDataFromZod.customFields \n            : undefined;\n\n          const serviceInput = {\n            ...dealDataFromZod,\n            expected_close_date: convertToDateOrNull(dealDataFromZod.expected_close_date),\n            customFields: customFieldsForService, // Use the processed customFields\n          };\n\n          const updatedDealRecord = await dealService.updateDeal(userId, args.id, serviceInput as Partial<GraphQLDealInput>, accessToken); // Changed cast\n          \n          return {\n            id: updatedDealRecord.id,\n            user_id: updatedDealRecord.user_id!,\n            created_at: updatedDealRecord.created_at,\n            updated_at: updatedDealRecord.updated_at,\n            name: updatedDealRecord.name!,\n            amount: updatedDealRecord.amount,\n            expected_close_date: updatedDealRecord.expected_close_date instanceof Date \n              ? updatedDealRecord.expected_close_date.toISOString() \n              : updatedDealRecord.expected_close_date,\n            stage_id: updatedDealRecord.stage_id!,\n            person_id: updatedDealRecord.person_id,\n            organization_id: updatedDealRecord.organization_id,\n            deal_specific_probability: updatedDealRecord.deal_specific_probability,\n          } as GraphQLDeal;\n      } catch (error) {\n          throw processZodError(error, action);\n      }\n    },\n    deleteDeal: async (_parent, args, context) => {\n      const action = `deleting deal ${args.id}`;\n      try {\n          requireAuthentication(context);\n          const accessToken = getAccessToken(context)!;\n          const userId = context.currentUser!.id;\n          if (!context.userPermissions?.includes('deal:delete_any')) {\n              throw new GraphQLError('Forbidden', { extensions: { code: 'FORBIDDEN' } });\n          }\n          const success = await dealService.deleteDeal(userId, args.id, accessToken);\n\n          if (success) {\n            inngest.send({\n              name: 'crm/deal.deleted',\n              data: { dealId: args.id },\n              user: { id: userId, email: context.currentUser!.email! }\n            }).catch((err: unknown) => console.error('Failed to send deal.deleted event to Inngest:', err));\n          }\n          return success;\n      } catch (error) {\n          throw processZodError(error, action);\n      }\n    },\n    reassignDeal: async (_parent: unknown, args: MutationReassignDealArgs, context: GraphQLContext) => {\n      const action = `reassigning deal ${args.dealId}`;\n      try {\n        requireAuthentication(context);\n        const actingUserId = context.currentUser!.id;\n        const accessToken = getAccessToken(context)!;\n\n        // Permission Check\n        if (!context.userPermissions?.includes('deal:reassign')) {\n          throw new GraphQLError('Forbidden: You do not have permission to reassign deals.', { \n            extensions: { code: 'FORBIDDEN' } \n          });\n        }\n\n        const { dealId, newOwnerUserId, addPreviousOwnerAsFollower } = args;\n\n        const reassignedDeal = await dealService.reassignDeal(\n          actingUserId, \n          dealId, \n          newOwnerUserId, \n          accessToken,\n          addPreviousOwnerAsFollower ?? true // Default to true if not provided\n        );\n        \n        // The service function already returns a Deal compatible type, but we ensure all non-nullable GraphQL fields are present.\n        // This mapping might be more robust if the service always returns all necessary fields or if we re-fetch.\n        // For now, trust the service layer's return matches GraphQLDeal structure for core fields.\n        return {\n          ...reassignedDeal,\n          id: reassignedDeal.id!,\n          user_id: reassignedDeal.user_id!,\n          created_at: reassignedDeal.created_at!,\n          updated_at: reassignedDeal.updated_at!,\n          name: reassignedDeal.name!,\n          stage_id: reassignedDeal.stage_id!,\n          // Ensure optional fields are correctly handled (e.g. person, organization might be null)\n          // The `as GraphQLDeal` cast below assumes the service returns a compatible structure.\n        } as GraphQLDeal;\n\n      } catch (error: unknown) {\n        console.error(`[Mutation.reassignDeal] Error during ${action}:`, error);\n        // processZodError might not be relevant here unless input validation is added.\n        if (error instanceof GraphQLError) throw error;\n        throw new GraphQLError(`Error ${action}.`, { extensions: { code: 'INTERNAL_SERVER_ERROR'} });\n      }\n    },\n}; ","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]