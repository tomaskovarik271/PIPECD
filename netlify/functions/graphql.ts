import { createYoga, createSchema } from 'graphql-yoga';
import type { Handler, HandlerEvent, HandlerContext } from '@netlify/functions';
import type { User } from '@supabase/supabase-js'; // Import User type
import { supabase } from '../../lib/supabaseClient'; // Import Supabase client
import { GraphQLError } from 'graphql'; // Import GraphQLError
import { contactService } from '../../lib/contactService'; // Import the contact service
import { dealService } from '../../lib/dealService'; // Import the deal service
import { z, ZodError } from 'zod'; // Import Zod and ZodError
import { inngest } from './inngest'; // Import the Inngest client

// Define GraphQL types related to User
type GraphQLContext = {
  currentUser: User | null;
  request: Request; // Add the original request object to context for header access
  event: HandlerEvent;
  context: HandlerContext;
};

// Helper to get token from context (or request headers)
function getAccessToken(context: GraphQLContext): string | null {
  const authHeader = context.request.headers.get('authorization');
  if (authHeader?.startsWith('Bearer ')) {
    return authHeader.substring(7);
  }
  return null;
}

// Zod schema for ContactInput validation
const ContactInputSchema = z.object({
  first_name: z.string().trim().min(1, { message: "First name cannot be empty if provided" }).optional().nullable(),
  last_name: z.string().trim().min(1, { message: "Last name cannot be empty if provided" }).optional().nullable(),
  email: z.string().trim().email({ message: "Invalid email address" }).optional().nullable(),
  phone: z.string().trim().optional().nullable(), // Add more specific phone validation if needed
  company: z.string().trim().optional().nullable(),
  notes: z.string().trim().optional().nullable(),
}).refine(data => data.first_name || data.last_name || data.email, {
  // Ensure at least one identifier is present
  message: "At least a first name, last name, or email is required",
  path: ["first_name"], // Assign error to a field for better client handling
});

// Zod schema for DealInput validation
const DealInputSchema = z.object({
    name: z.string().trim().min(1, { message: "Deal name cannot be empty" }),
    stage: z.string().trim().min(1, { message: "Deal stage cannot be empty" }), // Consider enum later
    amount: z.number().positive({ message: "Amount must be a positive number"}).optional().nullable(),
    contact_id: z.string().uuid({ message: "Invalid Contact ID format" }).optional().nullable(), // Assuming UUID for IDs
});

// Placeholder service functions (REMOVED)
// const contactService = { ... };
// const dealService = { ... };

// Define GraphQL Schema
const typeDefs = /* GraphQL */ `
  scalar DateTime
  scalar Float # Ensure Float is available if using it

  type Query {
    health: String!
    supabaseConnectionTest: String!
    me: UserInfo
    # Contacts
    contacts: [Contact!]!      # Get all contacts for the user
    contact(id: ID!): Contact  # Get a specific contact by ID
    contactList: [ContactListItem!]! # <-- Add query for dropdown list
    # Deals
    deals: [Deal!]!            # Get all deals for the user
    deal(id: ID!): Deal        # Get a specific deal by ID
  }

  type Mutation {
    # Contacts
    createContact(input: ContactInput!): Contact!
    updateContact(id: ID!, input: ContactInput!): Contact
    deleteContact(id: ID!): Boolean
    # Deals
    createDeal(input: DealInput!): Deal!
    updateDeal(id: ID!, input: DealInput!): Deal
    deleteDeal(id: ID!): Boolean
  }

  type UserInfo {
    id: ID!
    email: String
  }

  type Contact {
    id: ID!
    created_at: DateTime!
    updated_at: DateTime!
    user_id: ID! # Belongs to user
    first_name: String
    last_name: String
    email: String
    phone: String
    company: String
    notes: String
    deals: [Deal!] # Associated deals (add resolver if needed)
  }

  type Deal {
    id: ID!
    created_at: DateTime!
    updated_at: DateTime!
    user_id: ID! # Belongs to user
    name: String!
    stage: String! # e.g., 'Lead', 'Proposal', 'Closed Won'
    amount: Float
    contact_id: ID # Optional link to a contact
    contact: Contact # Associated contact (add resolver if needed)
  }

  # Simplified type for contact dropdowns
  type ContactListItem {
    id: ID!
    name: String! # Combined name generated by service
  }

  input ContactInput {
    first_name: String
    last_name: String
    email: String
    phone: String
    company: String
    notes: String
  }

  input DealInput {
    name: String!
    stage: String!
    amount: Float
    contact_id: ID
  }
`;

// Define Resolvers
const resolvers = {
  Query: {
    health: () => 'Ok',
    supabaseConnectionTest: async () => {
      try {
        // Attempt a simple read operation (e.g., get session)
        // This doesn't require a specific table to exist yet.
        const { data, error } = await supabase.auth.getSession();

        if (error) {
          console.error('Supabase connection error:', error.message);
          // Don't expose detailed errors to the client
          return `Connection Error: ${error.message}`;
        }

        console.log('Supabase getSession data:', data); // Log session data (will likely be null)
        return 'Successfully connected to Supabase (getSession succeeded)';
      } catch (err: any) {
        console.error('Unexpected error during Supabase test:', err);
        return `Unexpected Error: ${err.message}`;
      }
    },
    // Resolver for the 'me' query
    me: (_parent: unknown, _args: unknown, context: GraphQLContext) => {
      // Return minimal user info from context
      if (!context.currentUser) {
        return null; // Or throw an AuthenticationError
      }
      return {
        id: context.currentUser.id,
        email: context.currentUser.email,
        // Map other fields if needed
      };
    },

    // --- Contact Resolvers ---
    contacts: async (_parent: unknown, _args: unknown, context: GraphQLContext) => {
      if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
      const token = getAccessToken(context);
      if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });
      return contactService.getContacts(context.currentUser.id, token);
    },
    contact: async (_parent: unknown, args: { id: string }, context: GraphQLContext) => {
      if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
      const token = getAccessToken(context);
      if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });
      return contactService.getContactById(context.currentUser.id, args.id, token);
    },
    contactList: async (_parent: unknown, _args: unknown, context: GraphQLContext) => {
        if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
        const token = getAccessToken(context);
        if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });
        return contactService.getContactListForUser(context.currentUser.id, token);
    },

    // --- Deal Resolvers ---
    deals: async (_parent: unknown, _args: unknown, context: GraphQLContext) => {
        if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
        const token = getAccessToken(context);
        if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });
        // Call deal service (currently returns placeholder)
        return dealService.getDeals(context.currentUser.id, token);
    },
    deal: async (_parent: unknown, args: { id: string }, context: GraphQLContext) => {
        if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
        const token = getAccessToken(context);
        if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });
         // Call deal service (currently returns placeholder)
        return dealService.getDealById(context.currentUser.id, args.id, token);
    },
  },

  Mutation: {
    // --- Contact Mutations ---
    createContact: async (_parent: unknown, args: { input: any }, context: GraphQLContext) => {
      if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
      const token = getAccessToken(context);
      if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });
      
      // Validate input using Zod
      const validatedInput = ContactInputSchema.parse(args.input);
      // Now pass validatedInput to the service
      const newContact = await contactService.createContact(context.currentUser.id, validatedInput, token);

      // Send event to Inngest AFTER successful creation
      // Use await, but don't necessarily block the GraphQL response if sending fails
      try {
        await inngest.send({
          name: 'crm/contact.created', // Event name
          data: { // Event payload
            contactId: newContact.id,
            email: newContact.email,
            firstName: newContact.first_name,
          },
          user: { // Pass user info if available/useful for the event
            id: context.currentUser.id,
            email: context.currentUser.email,
          }
        });
        console.log(`Sent 'crm/contact.created' event for contact ID: ${newContact.id}`);
      } catch (eventError) {
        console.error("Failed to send Inngest event:", eventError);
        // Decide if this failure should cause the mutation to fail.
        // For logging, probably not critical, so we just log the error.
      }

      return newContact; // Return the created contact
    },
    updateContact: async (_parent: unknown, args: { id: string; input: any }, context: GraphQLContext) => {
      if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
      const token = getAccessToken(context);
      if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });

      // Validate input using Zod
      const validatedInput = ContactInputSchema.parse(args.input);
      // Now pass validatedInput to the service
      const updatedContact = await contactService.updateContact(context.currentUser.id, args.id, validatedInput, token);

      // TODO: Optionally send crm/contact.updated event here

      return updatedContact;
    },
    deleteContact: async (_parent: unknown, args: { id: string }, context: GraphQLContext) => {
      if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
      const token = getAccessToken(context);
      if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });
      
      const success = await contactService.deleteContact(context.currentUser.id, args.id, token);

      // TODO: Optionally send crm/contact.deleted event here (if success)
      
      return success;
    },

     // --- Deal Mutations ---
     createDeal: async (_parent: unknown, args: { input: any }, context: GraphQLContext) => {
        if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
        const token = getAccessToken(context);
        if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });

        // Validate input using Zod
        const validatedInput = DealInputSchema.parse(args.input);
        // Now pass validatedInput to the service
        const newDeal = await dealService.createDeal(context.currentUser.id, validatedInput, token);

        // Send event to Inngest AFTER successful creation
        // Use await, but don't necessarily block the GraphQL response if sending fails
        try {
            await inngest.send({
            name: 'crm/deal.created', // Event name
            data: { // Event payload - include relevant deal info
                dealId: newDeal.id,
                name: newDeal.name,
                stage: newDeal.stage,
                amount: newDeal.amount,
                contactId: newDeal.contact_id,
                // userId: newDeal.user_id, // Redundant if passed in user context
            },
            user: { // Pass user info if available/useful for the event
                id: context.currentUser.id,
                email: context.currentUser.email,
            }
            });
            console.log(`Sent 'crm/deal.created' event for deal ID: ${newDeal.id}`);
        } catch (eventError) {
            console.error("Failed to send Inngest event for deal creation:", eventError);
            // Decide if this failure should cause the mutation to fail.
            // For logging/auditing, maybe not critical, so just log the error.
        }

        return newDeal; // Return the created deal
    },
    updateDeal: async (_parent: unknown, args: { id: string; input: any }, context: GraphQLContext) => {
        if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
        const token = getAccessToken(context);
        if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });

        // Validate input using Zod
        const validatedInput = DealInputSchema.parse(args.input);
        // Now pass validatedInput to the service (currently returns placeholder)
        const updatedDeal = await dealService.updateDeal(context.currentUser.id, args.id, validatedInput, token);

        // TODO: Optionally send crm/deal.updated event here

        return updatedDeal; // Return updated deal (placeholder)
    },
    deleteDeal: async (_parent: unknown, args: { id: string }, context: GraphQLContext) => {
        if (!context.currentUser) throw new GraphQLError('Not authenticated', { extensions: { code: 'UNAUTHENTICATED' } });
        const token = getAccessToken(context);
        if (!token) throw new GraphQLError('Auth token missing', { extensions: { code: 'UNAUTHENTICATED' } });

        // Call deal service (currently returns placeholder)
        const success = await dealService.deleteDeal(context.currentUser.id, args.id, token);

        // TODO: Optionally send crm/deal.deleted event here (if success)

        return success; // Return boolean
    },
  },
  
  // Add resolver for nested Deal.contact field
  Deal: {
    contact: async (parentDeal: { contact_id: string | null, user_id: string }, _args: unknown, context: GraphQLContext) => {
        // Check if there is a contact_id on the parent Deal object
        if (!parentDeal.contact_id) {
            return null; // No contact linked
        }
        // Ensure user context exists (should generally be true if they fetched the parent Deal)
        if (!context.currentUser) {
             console.warn('Attempted to fetch Deal.contact without user context');
             return null; // Or throw error
        }
        // Get access token
        const token = getAccessToken(context);
        if (!token) {
             console.warn('Attempted to fetch Deal.contact without access token');
             return null; // Or throw error
        }
        
        // Fetch the contact using the contactService
        // We pass the parentDeal.user_id to ensure RLS check uses the *deal owner's* ID
        // Although, RLS on contacts table itself should handle this fine as well.
        try {
            // Note: Using parentDeal.user_id might be slightly less secure if ownership differs,
            // relying on context.currentUser.id and RLS policy is generally better.
            // Let's use the context user ID for consistency and rely on RLS.
            return await contactService.getContactById(context.currentUser.id, parentDeal.contact_id, token);
        } catch (error) {
            console.error(`Error fetching contact ${parentDeal.contact_id} for deal:`, error);
            // Don't fail the whole query, just return null for this field
            return null;
        }
    }
  }
  // TODO: Add resolver for Contact.deals if needed (would involve calling dealService.getDealsByContactId)
};

// Define the expected shape of the context passed *into* the factory by Yoga
// Typically includes the Request object and potentially others based on environment
interface YogaInitialParams {
  request: Request;
  // Include other params Yoga might pass, like the ones from server adapters
  event?: HandlerEvent; // Netlify specific
  context?: HandlerContext; // Netlify specific
}

// Define the final shape of the context object *returned* by the factory
// This is what resolvers will receive
interface ResolverContext extends YogaInitialParams { // Inherit initial params
  currentUser: User | null;
  // Add any other derived context properties here
}

// Create GraphQL Yoga instance with context factory
const yoga = createYoga<ResolverContext>({
  schema: createSchema({
    typeDefs,
    resolvers,
  }),
  // Context factory: receives initial params, returns the final ResolverContext
  context: async (initialContext: YogaInitialParams): Promise<ResolverContext> => {
    let currentUser: User | null = null;
    const authHeader = initialContext.request.headers.get('authorization');
    let token: string | null = null;

    if (authHeader?.startsWith('Bearer ')) {
      token = authHeader.substring(7);
      try {
        const { data: { user }, error } = await supabase.auth.getUser(token);
        if (error) {
          console.warn('JWT verification error:', error.message);
        } else {
          currentUser = user;
        }
      } catch (err) {
        console.error('Unexpected error during token verification:', err);
      }
    }

    // Return the full context object, explicitly merging initial params and derived values
    return {
      ...initialContext, // Pass through initial params like request, event, context
      currentUser,       // Add the derived user
    };
  },
  // Configure error masking
  maskedErrors: {
    maskError: (error, message, isDev) => {
      // Allow GraphQLErrors (like authentication errors) to pass through
      if (error instanceof GraphQLError) {
        return error;
      }
      // Handle Zod validation errors
      if (error instanceof ZodError) {
        // Combine Zod issues into a user-friendly message
        const validationMessage = error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join('; ');
        // Return a specific GraphQLError for validation issues
        return new GraphQLError(`Validation Error: ${validationMessage}`, {
          extensions: { code: 'BAD_USER_INPUT', validationErrors: error.flatten() }
        });
      }
      // Mask other unexpected errors in production
      if (!isDev) {
        console.error('Unexpected error in GraphQL resolver:', error); // Log the original error server-side
        return new GraphQLError('Internal Server Error', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });
      }
      // In development, return the original error for easier debugging
      return error as Error;
    },
  },
  // Enable/disable GraphiQL interface
  graphiql: process.env.NODE_ENV !== 'production', // Disable in production
  // Set the endpoint path for the GraphQL server
  graphqlEndpoint: '/.netlify/functions/graphql',
});

// Netlify Function Handler
export const handler: Handler = async (event, context) => {
  // Construct the URL for the Request object
  // Use x-forwarded-host/proto or fallback to Netlify env vars or defaults
  const protocol = event.headers['x-forwarded-proto'] || 'http';
  const host = event.headers['x-forwarded-host'] || event.headers.host || 'localhost';
  const url = new URL(yoga.graphqlEndpoint, `${protocol}://${host}`);

  // Create a standard Request object from the Netlify event
  const request = new Request(url.toString(), {
    method: event.httpMethod,
    headers: event.headers as HeadersInit, // Type assertion might be needed
    body: event.body ? Buffer.from(event.body, event.isBase64Encoded ? 'base64' : 'utf8') : undefined,
  });

  // Use yoga.fetch to handle the request
  const response = await yoga.fetch(
    request,
    // Pass Netlify event/context here; context factory might access them if needed
    // Note: Yoga's context factory primarily uses the standard Request object
    {
      event,
      context,
    }
  );

  // Prepare Netlify response headers
  const headers: { [key: string]: string } = {};
  const multiValueHeaders: { [key: string]: string[] } = {};

  response.headers.forEach((value, key) => {
    const lowerCaseKey = key.toLowerCase();
    if (lowerCaseKey === 'set-cookie') {
      // Use getSetCookie to handle multiple Set-Cookie headers correctly
      multiValueHeaders[key] = response.headers.getSetCookie();
    } else {
      // Assign single value headers
      headers[key] = value;
    }
  });

  // Convert Response back to Netlify format
  return {
    statusCode: response.status,
    body: await response.text(),
    headers: headers, // Use the single-value headers
    multiValueHeaders: multiValueHeaders, // Use the multi-value headers
  };
}; 