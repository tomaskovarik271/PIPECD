[{"filePath":"/Users/tomaskovarik/059_PIPECD/PIPECD/lib/teamService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1044,1047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1044,1047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5947,5950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5947,5950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7799,7802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7799,7802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SupabaseClient } from '@supabase/supabase-js';\nimport { Database } from './database.types'; // Corrected path\n// import { getAuthenticatedClient } from './serviceUtils'; // Assuming serviceUtils is in lib/\n// import { User } from './generated/graphql'; // For types if needed directly, or use DB types\n\n// Define a type for the database Team row\nexport type DbTeam = Database['public']['Tables']['teams']['Row'];\n\n/**\n * Fetches a single team by its ID.\n * Relies on RLS for row-level security.\n * \n * @param supabase The Supabase client instance.\n * @param teamId The ID of the team to fetch.\n * @returns The team object or null if not found/permitted.\n */\nexport const getTeamById = async (supabase: SupabaseClient<Database>, teamId: string): Promise<DbTeam | null> => {\n  const { data: dbTeam, error } = await supabase\n    .from('teams')\n    .select('*')\n    .eq('id', teamId)\n    .single();\n\n  if (error) {\n    console.error(`teamService.getTeamById: Error fetching team ${teamId}: ${(error as Error).message}`);\n    if ((error as any).code === 'PGRST116') return null; \n    throw error; \n  }\n  return dbTeam;\n};\n\nexport const createTeamInDb = async (\n  supabase: SupabaseClient<Database>, \n  input: { name: string; description?: string | null; teamLeadUserId?: string | null },\n  creatorUserId: string\n): Promise<DbTeam> => {\n  const { data: newDbTeam, error } = await supabase\n    .from('teams')\n    .insert({ \n      name: input.name, \n      description: input.description, \n      team_lead_user_id: input.teamLeadUserId, \n      created_by_user_id: creatorUserId \n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(`teamService.createTeamInDb: Error creating team - ${(error as Error).message}`);\n    throw error; \n  }\n  if (!newDbTeam) { \n    console.error('teamService.createTeamInDb: No data returned after insert, though no error reported.');\n    throw new Error('Team creation failed to return data.');\n  }\n  return newDbTeam;\n};\n\ninterface TeamsFilter { \n  // e.g. nameContains?: string;\n}\n\ninterface Pagination {\n  limit?: number | null;\n  offset?: number | null;\n}\n\nexport const getTeams = async (\n  supabase: SupabaseClient<Database>,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  filter?: TeamsFilter | null, \n  pagination?: Pagination | null\n): Promise<DbTeam[]> => {\n  let query = supabase.from('teams').select('*');\n\n  // if (filter?.nameContains) { // Placeholder for actual filter logic\n  //   query = query.ilike('name', `%${filter.nameContains}%`);\n  // }\n\n  if (pagination) {\n    const limit = pagination.limit ?? 20;\n    const offset = pagination.offset ?? 0;\n    query = query.range(offset, offset + limit - 1);\n  }\n\n  const { data: dbTeams, error } = await query;\n\n  if (error) {\n    console.error(`teamService.getTeams: Error fetching teams: ${(error as Error).message}`);\n    throw error;\n  }\n  return dbTeams || [];\n};\n\nexport const getTeamsForUser = async (\n  supabase: SupabaseClient<Database>,\n  userId: string\n): Promise<DbTeam[]> => {\n  // Fetch team_ids the user is a member of\n  const { data: teamMembers, error: tmError } = await supabase\n    .from('team_members')\n    .select('team_id')\n    .eq('user_id', userId);\n\n  if (tmError) {\n    console.error(`teamService.getTeamsForUser: Error fetching team memberships for user ${userId}:`, (tmError as Error).message);\n    throw tmError;\n  }\n\n  if (!teamMembers || teamMembers.length === 0) {\n    return [];\n  }\n\n  // The type of tm.team_id will be string as per the select.\n  // The generated type for team_members.Row is missing 'role', but team_id is present.\n  const teamIds = teamMembers.map(tm => tm.team_id);\n\n  const { data: teamsData, error: teamsError } = await supabase\n    .from('teams')\n    .select('*')\n    .in('id', teamIds);\n\n  if (teamsError) {\n    console.error(`teamService.getTeamsForUser: Error fetching teams for user ${userId} with IDs [${teamIds.join(',')}] :`, (teamsError as Error).message);\n    throw teamsError;\n  }\n  \n  return teamsData || [];\n};\n\nexport const getTeamsLedByUser = async (\n  supabase: SupabaseClient<Database>,\n  userId: string\n): Promise<DbTeam[]> => {\n  const { data: ledTeamsData, error } = await supabase\n    .from('teams')\n    .select('*')\n    .eq('team_lead_user_id', userId);\n  \n  if (error) {\n    console.error(`teamService.getTeamsLedByUser: Error fetching teams led by user ${userId}:`, (error as Error).message);\n    throw error;\n  }\n\n  return ledTeamsData || [];\n};\n\n// Use generated Update type if suitable, or define more specifically if needed\nexport type UpdateTeamDbInput = Partial<Pick<Database['public']['Tables']['teams']['Update'], 'name' | 'description' | 'team_lead_user_id'>>;\n\n\nexport const updateTeamInDb = async (\n  supabase: SupabaseClient<Database>,\n  teamId: string,\n  updatePayload: UpdateTeamDbInput \n): Promise<DbTeam> => {\n  const dbUpdatePayload: Database['public']['Tables']['teams']['Update'] = {};\n  if (updatePayload.name !== undefined) dbUpdatePayload.name = updatePayload.name;\n  if (updatePayload.description !== undefined) dbUpdatePayload.description = updatePayload.description;\n  // Ensure teamLeadUserId is handled correctly (null vs undefined)\n  if (updatePayload.team_lead_user_id !== undefined) dbUpdatePayload.team_lead_user_id = updatePayload.team_lead_user_id;\n\n\n  if (Object.keys(dbUpdatePayload).length === 0) {\n    console.warn('teamService.updateTeamInDb: Called with empty updatePayload. Fetching and returning existing team.');\n    const existingTeam = await getTeamById(supabase, teamId);\n    if (!existingTeam) throw new Error(`Team with ID ${teamId} not found for no-op update.`);\n    return existingTeam;\n  }\n\n  const { data: updatedDbTeam, error } = await supabase\n    .from('teams')\n    .update(dbUpdatePayload)\n    .eq('id', teamId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(`teamService.updateTeamInDb: Error updating team ${teamId}: ${(error as Error).message}`);\n    if ((error as any).code === 'PGRST116') { \n      throw new Error(`Team with ID ${teamId} not found or not permitted to update.`); \n    }\n    throw error;\n  }\n  if (!updatedDbTeam) {\n    console.error('teamService.updateTeamInDb: No data returned after update, though no error reported.');\n    throw new Error('Team update failed to return data.');\n  }\n  return updatedDbTeam;\n};\n\nexport const deleteTeamFromDb = async (\n  supabase: SupabaseClient<Database>,\n  teamId: string\n): Promise<{ success: boolean; count: number | null }> => {\n  const { error, count } = await supabase\n    .from('teams')\n    .delete()\n    .eq('id', teamId);\n\n  if (error) {\n    console.error(`teamService.deleteTeamFromDb: Error deleting team ${teamId}: ${(error as Error).message}`);\n    throw error; \n  }\n  return { success: true, count }; \n};\n\n// Explicitly define the type for team member insert, including role\ntype TeamMemberInsert = Database['public']['Tables']['team_members']['Insert'] & { role: string };\n// Define what we expect to get back, acknowledging 'role' might be missing from generated types\ntype TeamMemberRowWithRole = Database['public']['Tables']['team_members']['Row'] & { role?: string };\n\n\nexport const addTeamMemberToDb = async (\n  supabase: SupabaseClient<Database>,\n  teamId: string,\n  userId: string,\n  role?: string | null \n): Promise<TeamMemberRowWithRole> => {\n  // The 'role' field is NOT NULL and has a DEFAULT in the DB.\n  // The generated type Database['public']['Tables']['team_members']['Insert'] is missing 'role'.\n  // We ensure 'role' is part of the payload.\n  const insertPayload: TeamMemberInsert = { \n    team_id: teamId, \n    user_id: userId, \n    role: role || 'member' // Provide default if not specified, matching DB default\n  };\n\n  const { data: newMemberLink, error } = await supabase\n    .from('team_members')\n    .insert(insertPayload as any) // Cast to any because generated Insert type is missing 'role'\n    .select()\n    .single();\n\n  if (error) {\n    console.error(`teamService.addTeamMemberToDb: Error adding user ${userId} to team ${teamId}: ${(error as Error).message}`);\n    // TODO: Check for specific error codes, e.g., 23505 for PK violation if user is already in team with that role\n    throw error;\n  }\n  if (!newMemberLink) {\n    console.error('teamService.addTeamMemberToDb: No data returned after insert, though no error reported.');\n    throw new Error('Team member creation failed to return data.');\n  }\n  // The returned 'newMemberLink' will be of type Database['public']['Tables']['team_members']['Row']\n  // which is missing 'role'. We cast it to acknowledge 'role' should be there from the DB.\n  return newMemberLink as TeamMemberRowWithRole; \n};\n\nexport const removeTeamMemberFromDb = async (\n  supabase: SupabaseClient<Database>,\n  teamId: string,\n  userId: string\n): Promise<{ success: boolean; count: number | null }> => {\n  // This will delete all memberships for the user in the team, regardless of role,\n  // which is appropriate for \"removing a member from a team\".\n  // The primary key is (team_id, user_id, role), so deleting by just team_id and user_id\n  // will remove all matching entries.\n  const { error, count } = await supabase\n    .from('team_members')\n    .delete()\n    .match({ team_id: teamId, user_id: userId });\n\n  if (error) {\n    console.error(`teamService.removeTeamMemberFromDb: Error removing user ${userId} from team ${teamId}: ${(error as Error).message}`);\n    throw error;\n  }\n  return { success: true, count };\n};\n\n// Add more service functions here... ","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]